// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands */

/** tauri-specta globals */

import type { WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'
import {
  invoke as TAURI_INVOKE,
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'

export const commands = {
  async completeLastfmAuth(token: string): Promise<Result<string, Error>> {
    try {
      return { data: await TAURI_INVOKE('complete_lastfm_auth', { token }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async controlPlayback(action: StreamAction): Promise<Result<StreamStatus, Error>> {
    try {
      return { data: await TAURI_INVOKE('control_playback', { action }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async getCanonicalPath(path: string): Promise<Result<string, Error>> {
    try {
      return { data: await TAURI_INVOKE('get_canonical_path', { path }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async getFolderTrackPaths(path: string, deep: boolean | null): Promise<Result<string[], Error>> {
    try {
      return { data: await TAURI_INVOKE('get_folder_track_paths', { deep, path }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async getLastfmAuthStatus(): Promise<Result<boolean, Error>> {
    try {
      return { data: await TAURI_INVOKE('get_lastfm_auth_status'), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async getTrackData(pathString: string, refresh: boolean | null): Promise<Result<FileEntry, Error>> {
    try {
      return { data: await TAURI_INVOKE('get_track_data', { pathString, refresh }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async getTracksData(paths: string[]): Promise<FileEntry[]> {
    return await TAURI_INVOKE('get_tracks_data', { paths })
  },
  async getWaveform(path: string, binSize: number): Promise<Result<number[], Error>> {
    try {
      return { data: await TAURI_INVOKE('get_waveform', { binSize, path }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async openLastfmAuth(): Promise<Result<string, Error>> {
    try {
      return { data: await TAURI_INVOKE('open_lastfm_auth'), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async processOfflineScrobbles(scrobbles: SerializedOfflineScrobble[]): Promise<Result<SerializedScrobbleResponse, Error>> {
    try {
      return { data: await TAURI_INVOKE('process_offline_scrobbles', { scrobbles }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async readFolder(path: string): Promise<Result<FileEntry[], Error>> {
    try {
      return { data: await TAURI_INVOKE('read_folder', { path }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async removeLastfmAccount(): Promise<Result<null, Error>> {
    try {
      return { data: await TAURI_INVOKE('remove_lastfm_account'), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async scrobbleTrack(scrobble: SerializedScrobble): Promise<Result<SerializedScrobbleResponse, Error>> {
    try {
      return { data: await TAURI_INVOKE('scrobble_track', { scrobble }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async setNowPlaying(scrobble: SerializedScrobble): Promise<Result<null, Error>> {
    try {
      return { data: await TAURI_INVOKE('set_now_playing', { scrobble }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
  async writeId3Frames(filePath: string, targetTag: TagTypeArg, args: FrameArgs[]): Promise<Result<null, Error>> {
    try {
      return { data: await TAURI_INVOKE('write_id3_frames', { args, filePath, targetTag }), status: 'ok' }
    }
    catch (e) {
      if (e instanceof Error)
        throw e
      else return { error: e as any, status: 'error' }
    }
  },
}

/** user-defined events */

/** user-defined constants */

/** user-defined types */

export type Error = { type: 'Audio', data: string } | { type: 'Backend', data: string } | { type: 'Id3', data: string } | { type: 'FileSystem', data: string } | { type: 'LastFm', data: string } | { type: 'Waveform', data: string } | { type: 'Sql', data: string } | { type: 'Store', data: string } | { type: 'Stronghold', data: string } | { type: 'Other', data: string }
export interface FileEntry { path: string, name: string, filename: string, tags: Partial<{ [key in string]: string }>, thumbnail_uri: string, full_uri: string, is_playlist_track: boolean, valid: boolean, primary_tag: TagTypeArg | null, extension: string }
export interface FrameArgs { frame: string, value: string }
export interface SerializedOfflineScrobble { scrobble: SerializedScrobble, timestamp: number }
export interface SerializedScrobble { artist: string, track: string, album: string | null, track_number: number | null, duration: number, album_artist: string | null }
export interface SerializedScrobbleResponse { accepted: number, ignored: number }
export type StreamAction = { Play: string } | 'Pause' | 'Resume' | { Seek: number } | { SetLoop: boolean } | { SetVolume: number } | 'ToggleMute' | 'Reset'
export interface StreamStatus { is_playing: boolean, position: number, duration: number, is_looping: boolean, path: string | null, volume: number, is_muted: boolean }
export type TagTypeArg = 'id3v2.2' | 'id3v2.3' | 'id3v2.4'

interface __EventObj__<T> {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E>
  = | { status: 'ok', data: T }
    | { status: 'error', error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            emit: (arg: any) => window.emit(name, arg),
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    },
  )
}
