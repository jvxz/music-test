# Cursor Rules for Nuxt 4 + Tauri 2 Desktop Application

## Project Overview
This is a Nuxt 4 desktop application built with Tauri 2, using TypeScript, Tailwind CSS v4, VueUse, and Bun as the package manager. The application runs in SPA mode (SSR disabled) and targets desktop platforms.

## Core Technologies & Versions
- **Nuxt**: 4.2.1+
- **Vue**: 3.5.25+
- **Tauri**: 2.9.1+
- **Tailwind CSS**: 4.1.17+
- **VueUse**: 14.1.0+
- **TypeScript**: 5.7.3+
- **Package Manager**: Bun 1.3.3+
- **Node**: >=23

## Nuxt 4 Conventions & Best Practices

### Directory Structure
- Use Nuxt's convention-based directory structure:
  - `app/pages/` - File-based routing (auto-imported)
  - `app/components/` - Auto-imported Vue components
  - `app/composables/` - Auto-imported composables
  - `app/layouts/` - Layout components
  - `app/modules/` - Custom Nuxt modules (configured in `nuxt.config.ts`)
  - `app/assets/` - Static assets (CSS, images, SVG)
  - `types/` - TypeScript type definitions

### Auto-Imports
- Nuxt auto-imports composables, components, and utilities. Don't manually import:
  - Vue composables (`ref`, `computed`, `watch`, etc.)
  - Nuxt composables (`useRouter`, `useRoute`, `useHead`, etc.)
  - Components from `app/components/`
  - Composables from `app/composables/`
- Custom imports are configured in `nuxt.config.ts`:
  - Zod: `z` and `zInfer` (type helper)
  - Tauri APIs: Auto-prefixed with `useTauri` via custom module

### File-Based Routing
- Pages in `app/pages/` automatically become routes
- Use `route.meta` for page metadata (category, description, icon, name)
- Use `router.options.ts` for custom scroll behavior (currently set to 'smooth')
- Layout transitions: `mode: 'out-in'`, `name: 'layout'`
- Page transitions: `mode: 'out-in'`, `name: 'page'`

### TypeScript Configuration
- Use `experimental.typedPages: true` for typed routes
- Use `experimental.typescriptPlugin: true` for enhanced TypeScript support
- Type definitions go in `types/global.d.ts`

### Module Development
- Custom modules in `app/modules/` (configured via `dir.modules`)
- Always prefix exposed interfaces (composables, components, APIs) to prevent conflicts
- Example: `useTauriApp`, `useTauriShell`, etc. (not `useApp`, `useShell`)

### SSR & Rendering
- **SSR is disabled** (`ssr: false`) - this is an SPA application
- All rendering happens client-side
- Use `onMounted()` for browser-only code

## Vue 3 Composition API Patterns

### Script Setup Syntax
- **Always use `<script setup lang="ts">`** for components
- Prefer Composition API over Options API
- Use `defineProps<T>()` and `defineEmits<T>()` for type-safe props/emits

### Reactive State
- Use `ref()` for primitives and single values
- Use `reactive()` sparingly (prefer `ref()` for better TypeScript support)
- Use `computed()` for derived state
- Use `watch()` and `watchEffect()` for side effects

### Composables Pattern
- Extract reusable logic into composables in `app/composables/`
- Composables should:
  - Return an object with reactive state and methods
  - Use `use` prefix (e.g., `usePages`, `useTauriApp`)
  - Be fully typed with TypeScript
  - Handle cleanup in `onUnmounted()` if needed

### Component Organization
- Organize Composition API code like normal JavaScript:
  - Group related reactive state together
  - Group related computed properties together
  - Group related watchers together
  - Group lifecycle hooks together
- Use comments to separate logical sections if needed

### Template Best Practices
- Use kebab-case for component names in templates
- Use PascalCase for component file names
- Prefer explicit prop names over v-bind with objects when possible
- Use `v-if` vs `v-show` appropriately (v-if for conditional rendering, v-show for toggling visibility)

## Tauri 2 Integration

### Tauri Composables
- All Tauri APIs are auto-imported with `useTauri` prefix:
  - `useTauriApp*` - App lifecycle and info
  - `useTauriWebviewWindow*` - Window management
  - `useTauriShell*` - Shell commands
  - `useTauriOs*` - OS information
  - `useTauriNotification*` - System notifications
  - `useTauriFs*` - File system operations
  - `useTauriStore*` - Persistent storage

### Tauri Module Pattern
- Custom module in `app/modules/tauri.ts` handles auto-imports
- Prefix pattern: `useTauri{Module}{Function}` (e.g., `useTauriAppGetVersion`)
- Always check if Tauri APIs are available before using (use `import.meta.env.TAURI_PLATFORM`)

### File System Operations
- Always call `file.close()` after file operations
- Use proper error handling for file system operations
- Prefer async/await over promises for readability

### Window Management
- Use `useTauriWebviewWindow*` for window operations
- Consider window state persistence for better UX

## Tailwind CSS v4 Best Practices

### Utility-First Approach
- Use utility classes directly in templates
- Prefer utilities over custom CSS
- Extract repeated patterns into Vue components, not CSS classes

### Responsive Design
- Use mobile-first approach: unprefixed utilities target mobile
- Breakpoints: `sm:`, `md:`, `lg:`, `xl:`, `2xl:`
- Example: `text-center md:text-left` (centered on mobile, left on desktop)

### Dynamic Classes
- Map props to complete class names that are statically detectable
- Avoid dynamically constructing class strings
- Use `computed()` for conditional classes
- Example: `const buttonClass = computed(() => props.variant === 'primary' ? 'bg-primary' : 'bg-secondary')`

### Component Extraction
- Extract repeated utility patterns into reusable Vue components
- Keep components focused and composable
- Use props to control styling variants

### Inline Styles
- Use inline styles for:
  - Dynamic values from APIs/databases
  - Complex arbitrary values difficult to read as classes
  - CSS variables set from dynamic sources

## VueUse Composables

### Available Composables
- VueUse is auto-imported via `@vueuse/nuxt` module
- Use composables from `@vueuse/core` for common utilities
- Check VueUse docs for available composables before writing custom logic

### Common Patterns
- `useVModel` - Two-way binding with props
- `useCounter` - Counter state management
- `useNow` - Reactive current time
- `useFileSystemAccess` - File system operations (complements Tauri)
- `useArrayMap`, `useArrayFilter`, etc. - Array utilities

### Best Practices
- Prefer VueUse composables over custom implementations
- Check composable return types for proper destructuring
- Use TypeScript for type safety with VueUse composables

## TypeScript Patterns

### Type Safety
- Always use TypeScript types, avoid `any`
- Use `interface` for object shapes, `type` for unions/intersections
- Leverage Nuxt's auto-generated types (`useRouter`, `useRoute`, etc.)

### Zod Integration
- Use Zod (`z`) for runtime validation
- Use `zInfer` (imported as type) to extract TypeScript types from Zod schemas
- Example: `type User = zInfer<typeof userSchema>`

### Component Props & Emits
- Use `defineProps<T>()` for typed props
- Use `defineEmits<T>()` for typed emits
- Define interfaces/types for complex prop shapes

### Composables Typing
- Return types should be explicit
- Use `ComputedRef<T>`, `Ref<T>`, `MaybeRef<T>` from Vue
- Export types for composable return values when reusable

## Code Organization & Structure

### File Naming
- Components: PascalCase (e.g., `UserProfile.vue`)
- Composables: camelCase with `use` prefix (e.g., `usePages.ts`)
- Utilities: camelCase (e.g., `formatDate.ts`)
- Types: camelCase with `.d.ts` extension or in `types/` directory

### Import Organization
- Group imports: Vue/Nuxt → Third-party → Local
- Use absolute imports with `@/` alias (configured by Nuxt)
- Leverage auto-imports - don't manually import auto-imported items

### Component Structure
```vue
<script setup lang="ts">
// 1. Type imports
import type { SomeType } from '@/types'

// 2. Props & emits
const props = defineProps<{...}>()
const emit = defineEmits<{...}>()

// 3. Composables
const router = useRouter()
const { data } = useAsyncData(...)

// 4. Reactive state
const count = ref(0)
const name = ref('')

// 5. Computed
const doubled = computed(() => count.value * 2)

// 6. Watchers
watch(count, (newVal) => {...})

// 7. Lifecycle hooks
onMounted(() => {...})

// 8. Methods
function handleClick() {...}
</script>

<template>
  <!-- Template content -->
</template>

<style scoped>
/* Component-specific styles (use Tailwind utilities when possible) */
</style>
```

## ESLint & Code Quality

### ESLint Configuration
- Uses `@antfu/eslint-config` with Nuxt integration
- Formatters enabled (Prettier-like)
- TypeScript and Vue plugins enabled
- Better Tailwind CSS plugin for class ordering

### Code Style Rules
- `perfectionist/sort-objects`: Warn (object key sorting)
- `vue/html-self-closing`: Off
- `vue/max-attributes-per-line`: Warn (1 multiline, 2 singleline)
- `vue/sort-keys`: Warn
- `better-tailwindcss`: Recommended rules enabled

### Best Practices
- Run `bun run lint` before committing
- Fix auto-fixable issues automatically
- Follow Vue style guide recommendations
- Keep components small and focused
- Extract logic into composables when reused

## Performance Considerations

### Nuxt Optimizations
- Code splitting is automatic via file-based routing
- Components are lazy-loaded by default
- Use `defineAsyncComponent()` for heavy components
- Leverage Nuxt's built-in optimizations

### Vue Performance
- Use `v-memo` for expensive list rendering
- Use `v-once` for static content
- Avoid unnecessary reactivity (use `shallowRef` for large objects)
- Use `computed` instead of methods in templates when possible

### Tauri Considerations
- Minimize IPC calls (batch operations when possible)
- Use Tauri Store for persistent data instead of localStorage
- Consider window state management for better performance

## Testing & Development

### Development Server
- Frontend: `bun run nuxt:dev` (port 3000)
- Tauri Dev: `bun run dev` (launches desktop app)
- HMR configured for port 3001 with WebSocket protocol

### Environment Variables
- Use `VITE_` or `TAURI_` prefix for environment variables
- Access via `import.meta.env.VITE_*` or `import.meta.env.TAURI_*`

### Debugging
- Use Vue DevTools for component debugging
- Use browser DevTools for frontend debugging
- Use Rust debugging tools for Tauri backend
- Check Tauri console for IPC communication

## Common Patterns & Examples

### Page with Metadata
```vue
<script setup lang="ts">
definePageMeta({
  name: 'User Profile',
  description: 'View and edit user profile',
  icon: 'i-lucide-user',
  category: 'settings'
})
</script>
```

### Tauri File Operation
```vue
<script setup lang="ts">
const { readTextFile, writeTextFile } = useTauriFs()

async function loadFile() {
  try {
    const content = await readTextFile('path/to/file.txt')
    // Handle content
  } catch (error) {
    // Handle error
  }
}
</script>
```

### Composable Pattern
```vue
<script setup lang="ts">
// app/composables/useCounter.ts
export function useCounter(initial = 0) {
  const count = ref(initial)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = initial
  
  return {
    count: readonly(count),
    increment,
    decrement,
    reset
  }
}
</script>
```

## Additional Notes

- **Package Manager**: Always use Bun, not npm/yarn/pnpm
- **Node Version**: Requires Node >=23
- **Build**: Use `bun run tauri:build` for production builds
- **SVG**: Use `nuxt-svgo` for optimized SVG imports (auto-imported from `@/assets/`)
- **Icons**: Use Iconify format: `i-{collection}-{name}`

## When in Doubt

1. Check Nuxt 4 documentation: https://nuxt.com/docs/4.x
2. Check Tauri 2 documentation: https://v2.tauri.app
3. Check VueUse documentation: https://vueuse.org
4. Check Tailwind CSS v4 documentation: https://tailwindcss.com/docs
5. Follow existing code patterns in the codebase
6. Use Context7 MCP for up-to-date library documentation

